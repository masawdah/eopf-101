name: Quarto Test Render

on:
  workflow_dispatch:
  pull_request:

jobs:
  check-diff:
    runs-on: ubuntu-latest
    outputs:
      build: ${{ steps.check.outputs.build }}
      tag: ${{ steps.check.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for relevant file changes
        id: check
        run: |
          git fetch origin ${{ github.base_ref }}
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)

          if echo "$CHANGED_FILES" | grep -qE '^pyproject\.toml$|^uv\.lock$|^deployment/Dockerfile(_|$)|^deployment/environment\.yaml$'; then
            echo "Building image as we've modified pyproject.toml or deployment Dockerfile in this PR"
            echo "build=true" >> $GITHUB_OUTPUT
            echo "tag=pr-${{ github.run_id }}" >> $GITHUB_OUTPUT
          else
            echo "Using latest image"
            echo "build=false" >> $GITHUB_OUTPUT
            echo "tag=latest" >> $GITHUB_OUTPUT
          fi

  prepare-docker-image:
    runs-on: ubuntu-latest
    needs: check-diff
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        if: needs.check-diff.outputs.build == 'true'

      - name: Login to OVH Harbor docker registry
        uses: docker/login-action@v3
        if: needs.check-diff.outputs.build == 'true'
        with:
          registry: ${{ secrets.OVH_HARBOR_REGISTRY }}
          username: ${{ secrets.OVH_HARBOR_USERNAME }}
          password: ${{ secrets.OVH_HARBOR_PASSWORD }}

      # We use the R image as this contains the same Python Dependencies as the Python one, so should work for everything
      - name: build image
        working-directory: deployment
        if: needs.check-diff.outputs.build == 'true'
        run: |
          make build-and-push-docker-image TAG=${{ needs.check-diff.outputs.tag }} PROJECT="r"

  test-render:
    needs: [check-diff, prepare-docker-image]
    runs-on: eopf-large
    if: needs.check-diff.result == 'success' && (needs.prepare-docker-image.result == 'success' || needs.prepare-docker-image.result == 'skipped')
    container:
      # We use the R image as this contains the same Python Dependencies as the Python one, so should work for everything
      image: 4zm3809f.c1.de1.container-registry.ovh.net/eopf-toolkit-r/eopf-toolkit-r:${{ needs.check-diff.outputs.tag }}
      options: --entrypoint "" --user root

    steps:
      # Quarto uses these but we probably don't want them baked into our image
      - name: Install quarto system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
          git \
          gh \
          curl \
          jq \
          libfontconfig1 \
          libfreetype6 \
          libx11-6 \
          libxrender1 \
          libxext6 \
          ghostscript \
          zlib1g

      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install quarto python dependencies
        run: |
          pip install uv
          uv sync
          pip install nbstripout

      - name: Validate notebooks are clean
        shell: bash
        run: |
          echo "ðŸ” Checking that all notebooks are clean (no outputs)..."
          # Find all notebooks excluding backups and build artifacts
          notebooks=$(find . -name "*.ipynb" -not -path "./_book/*" -not -name "*backup*.ipynb" -not -path "./.git/*" -not -path "./.venv/*")
          if [ -z "$notebooks" ]; then
            echo "â„¹ï¸  No notebooks found to validate"
            exit 0
          fi
          echo "Found notebooks: $notebooks"
          # Use nbstripout --verify which exits with non-zero if notebooks have outputs
          if nbstripout --verify $notebooks; then
            echo "âœ… All notebooks are clean!"
          else
            echo ""
            echo "âŒ Some notebooks contain outputs or execution counts!"
            echo ""
            echo "ðŸ”§ To fix this:"
            echo "  1. Install nbstripout: pip install nbstripout"
            echo "  2. Clean notebooks: nbstripout *.ipynb"
            echo "  3. Commit the changes"
            echo ""
            echo "ðŸ’¡ For automatic cleaning, set up git hooks: nbstripout --install"
            exit 1
          fi

      - name: Set up Quarto
        uses: quarto-dev/quarto-actions/setup@v2
        with:
          tinytex: true

      - name: Trust git repo
        run: |
          git config --global --add safe.directory /__w/eopf-101/eopf-101

      - name: Identify new/modified .ipynb and .qmd files
        id: changed
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE="${{ github.event.pull_request.base.sha }}"
            HEAD="${{ github.event.pull_request.head.sha }}"
          else
            BASE="${{ github.event.before }}"
            HEAD="${{ github.sha }}"
          fi

          echo "Diffing range: $BASE..$HEAD"
          git --no-pager show --name-only --pretty=oneline "$BASE..$HEAD" | sed 's/^/  /' || true

          # 1) Get ALL changed paths (null-delimited)
          git -c core.quotepath=off diff -z --name-only --diff-filter=AMR "$BASE" "$HEAD" -- > all.lst

          # 2) Filter to *.qmd / *.ipynb safely (null-aware)
          : > changed.lst
          while IFS= read -r -d '' f; do
            case "$f" in
              *.qmd|*.ipynb) printf '%s\0' "$f" >> changed.lst ;;
            esac
          done < all.lst

          if [[ -s changed.lst ]]; then
            echo "Changed notebooks/files:"
            tr '\0' '\n' < changed.lst | sed 's/^/  /'
          else
            echo "none=true" >> "$GITHUB_OUTPUT"
            echo "No matching files changed."
          fi

      - name: Render changed files (standalone)
        if: steps.changed.outputs.none != 'true'
        shell: bash
        working-directory: ${{ github.workspace }}
        run: |
          set -euo pipefail
          while IFS= read -r -d '' f; do
            echo "Rendering (standalone): $f"
            quarto render "$f" --to html
          done < changed.lst
        env:
          BUCKET_NAME: ${{ secrets.RENDER_BUCKET_NAME }}
          ACCESS_KEY: ${{ secrets.RENDER_BUCKET_ACCESS_KEY }}
          SECRET_KEY: ${{ secrets.RENDER_BUCKET_SECRET_KEY }}
          BUCKET_ENDPOINT: ${{ secrets.RENDER_BUCKET_ENDPOINT }}
